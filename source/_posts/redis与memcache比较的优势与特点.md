---
title: redis与memcache比较的优势与特点
date: 2020-12-27 21:10:59
tags:
category: redis
---


因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。（以上主要来自官方FAQ）既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求,单线程可以处理高并发请求吗？  
    
当然可以了，Redis都实现了。有一点概念需要澄清，并发并不是并行。  
（相关概念：并发性I/O流，意味着能够让一个计算单元来处理来自多个客户端的流请求。并行性，意味着服务器能够同时执行几个事情，具有多个计算单元）


Redis总体快速的原因：
采用队列模式将并发访问变为串行访问
单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），其他模块仍用了多个线程。

总体来说快速的原因如下：
1）绝大部分请求是纯粹的内存操作（非常快速）
2）采用单线程,避免了不必要的上下文切换和竞争条件
3）非阻塞IO
内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间
这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。


1.Redis服务端是个单线程的架构，不同的Client虽然看似可以同时保持连接，但发出去的命令是序列化执行的，这在通常的数据库理论下是最高级别的隔离（serialize)  
2.用MULTI/EXEC 来把多个命令组装成一次发送，达到原子性  
3.用WATCH提供的乐观锁功能，在你EXEC的那一刻，如果被WATCH的键发生过改动，则MULTI到EXEC之间的指令全部不执行，不需要rollback  
4.其他回答中提到的DISCARD指令只是用来撤销EXEC之前被暂存的指令，并不是回滚  


1.使用Redis有哪些好处？  
(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)  
(2) 支持丰富数据类型，支持string，list，set，sorted set，hash  
(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行  
(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除    

 
2.Redis相比memcached有哪些优势？  
(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型  
(2) redis的速度比memcached快很多  
(3) redis可以持久化其数据  
(4)Redis支持数据的备份，即master-slave模式的数据备份。  
(5)、使用底层模型不同  
它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。  
Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。  
(6）value大小：redis最大可以达到1GB，而memcache只有1MB  


redis的一些其他特点:  
(1)Redis是单进程单线程的  
redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销

(2)读写分离模型
通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。
读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。

(3)数据分片模型
为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。
可以将每个节点看成都是独立的master，然后通过业务实现数据分片。  
结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。  



什么时候倾向于选择memcache？
纯kv，数据量非常大，并发量非常大的业务，使用mc或许更合适
